var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

import React from 'react';
import ReactDOM from 'react-dom';

var DEFAULT_NO_OF_COLS = 12;
var DEFAULT_CELL_MARGIN_X = 10;
var DEFAULT_CELL_MARGIN_Y = 10;

var DEFAULT_CHILD_HEIGHT = 1;
var DEFAULT_CHILD_WIDTH = 1;

var FREE_CELL = 0;
var FILLED_CELL = 1;

var calculateChildPosition = function calculateChildPosition(_ref) {
  var grid = _ref.grid,
      minRow = _ref.minRow,
      childWidth = _ref.childWidth;


  for (var r = minRow; r < grid.length; r++) {
    var row = grid[r];
    for (var c = 0; c < row.length; c++) {

      var found = true;
      for (var k = 0; k < childWidth; k++) {
        if (row[c + k] !== FREE_CELL) {
          found = false;
          break;
        }
      }
      if (found) {
        return { top: r, left: c };
      }
    }
  }

  return { left: 0, top: grid.length };
};

var getBreakpointForWidth = function getBreakpointForWidth(_ref2) {
  var breakpoints = _ref2.breakpoints,
      layoutWidth = _ref2.layoutWidth;

  if (breakpoints && breakpoints.length) {
    var sortedBreakpoints = breakpoints.sort(function (a, b) {
      return b.width - a.width;
    });
    var breakPoint = sortedBreakpoints.find(function (x) {
      return layoutWidth >= x.width;
    });
    return breakPoint || sortedBreakpoints[0];
  } else {
    return null;
  }
};

var getCellMargin = function getCellMargin(marginProp) {
  if (marginProp && marginProp.length === 2) {
    return {
      x: typeof marginProp[0] === 'number' ? marginProp[0] : DEFAULT_CELL_MARGIN_X,
      y: typeof marginProp[1] === 'number' ? marginProp[1] : DEFAULT_CELL_MARGIN_Y
    };
  } else {
    return {
      x: DEFAULT_CELL_MARGIN_X,
      y: DEFAULT_CELL_MARGIN_Y
    };
  }
};

var ReactDashboardLayout = function (_React$Component) {
  _inherits(ReactDashboardLayout, _React$Component);

  function ReactDashboardLayout(props) {
    _classCallCheck(this, ReactDashboardLayout);

    var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));

    _this.onWindowResize = function () {
      if (_this.mounted) {
        var node = _this.myRef.current;
        if (node instanceof HTMLElement) {
          if (node.offsetWidth !== _this.state.width || node.offsetHeight !== _this.state.height) {
            _this.setState({
              width: node.offsetWidth,
              height: node.offsetHeight
            });
          }
        }
      }
    };

    _this.myRef = React.createRef();
    _this.state = {
      width: 1280,
      height: 800
    };
    _this.mounted = false;
    return _this;
  }

  ReactDashboardLayout.prototype.componentDidMount = function componentDidMount() {
    this.mounted = true;
    window.addEventListener("resize", this.onWindowResize);
    this.onWindowResize();
  };

  ReactDashboardLayout.prototype.componentDidUpdate = function componentDidUpdate() {
    this.onWindowResize();
  };

  ReactDashboardLayout.prototype.componentWillUnmount = function componentWillUnmount() {
    this.mounted = false;
    window.removeEventListener("resize", this.onWindowResize);
  };

  ReactDashboardLayout.prototype.render = function render() {
    var _this2 = this;

    if (!this.mounted) {
      return React.createElement('div', { ref: this.myRef, style: { width: '100%', height: '100%' } });
    }

    // find breakpoint for current layout width
    var breakpoint = getBreakpointForWidth({
      breakpoints: this.props.breakpoints,
      layoutWidth: this.state.width
    });

    // determine number of columns for the layout
    var layoutCols = breakpoint ? breakpoint.cols : this.props.cols || DEFAULT_NO_OF_COLS;

    // get margin between cells
    var cellMargin = getCellMargin(this.props.margin);

    // calculate current width and height of a cell
    var cellWidth = this.state.width / layoutCols;
    var cellHeight = this.props.rows ? this.state.height / this.props.rows : cellWidth;

    var grid = [];
    var minRow = 0;

    // clone all child components and set position and dimensions to absolute values
    var children = React.Children.map(this.props.children, function (child, i) {

      var gridProp = child.props['data-grid'];
      var childHeight = gridProp && gridProp.h || DEFAULT_CHILD_HEIGHT;
      var childWidthTemp = gridProp && gridProp.w || DEFAULT_CHILD_WIDTH;

      // if child width is greater than number of cols in layout, then change child width
      var childWidth = childWidthTemp > layoutCols ? layoutCols : childWidthTemp;

      // get child position
      var childPosition = calculateChildPosition({ grid: grid, minRow: minRow, childWidth: childWidth });

      // if layout is of type 'fill screen' and child is below max screen height, then don't show it
      if (_this2.props.rows && _this2.props.rows <= childPosition.top) {
        return null;
      }

      minRow = childPosition.top;

      // add new rows to the grid if the grid is not yet 'high' enough
      if (childPosition.top + childHeight > grid.length) {
        for (var r = grid.length; r < childPosition.top + childHeight; r++) {
          var newRow = [];
          for (var c = 0; c < layoutCols; c++) {
            newRow.push(FREE_CELL);
          }
          grid.push(newRow);
        }
      }

      // mark grid cells as filled with dimensions of current child
      for (var _r = 0; _r < childHeight; _r++) {
        for (var _c = 0; _c < childWidth; _c++) {
          if (childPosition.top + _r < grid.length && childPosition.left + _c < grid[0].length) {
            grid[childPosition.top + _r][childPosition.left + _c] = FILLED_CELL;
          }
        }
      }

      // define new style properties
      var style = _extends({}, child.props.style, {
        boxSizing: 'border-box',
        position: 'absolute',
        left: childPosition.left * cellWidth + cellMargin.x / 2,
        width: childWidth * cellWidth - cellMargin.x + 'px',
        top: childPosition.top * cellHeight + cellMargin.y / 2,
        height: childHeight * cellHeight - cellMargin.y + 'px'

        // clone and return child component with new style propeties
      });return React.cloneElement(child, { style: style, key: 'child-' + i });
    });

    var layoutHeight = this.props.rows ? '100%' : cellHeight * grid.length + 'px';

    return React.createElement(
      'div',
      { ref: this.myRef, style: { boxSizing: 'border-box', height: layoutHeight, position: 'relative' } },
      children
    );
  };

  return ReactDashboardLayout;
}(React.Component);

export { ReactDashboardLayout as default };